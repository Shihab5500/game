<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Balloon Pop â€“ Kids Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    canvas { touch-action: manipulation; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-sky-100 to-emerald-100 select-none">
  <div class="max-w-3xl mx-auto p-4">
    <header class="flex items-center justify-between gap-2 mb-3">
      <h1 class="text-2xl md:text-3xl font-bold text-sky-700">ðŸŽˆ Balloon Pop</h1>
      <div class="flex items-center gap-2">
        <button id="btn-start" class="px-4 py-2 rounded-2xl bg-sky-600 text-white text-sm md:text-base shadow hover:brightness-110 active:scale-95">Start</button>
        <button id="btn-reset" class="px-4 py-2 rounded-2xl bg-emerald-600 text-white text-sm md:text-base shadow hover:brightness-110 active:scale-95">Reset</button>
      </div>
    </header>

    <section class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3 text-center">
      <div class="bg-white/70 rounded-2xl p-3 shadow">
        <div class="text-xs text-slate-500">Score</div>
        <div id="score" class="text-xl md:text-2xl font-bold">0</div>
      </div>
      <div class="bg-white/70 rounded-2xl p-3 shadow">
        <div class="text-xs text-slate-500">Time</div>
        <div id="time" class="text-xl md:text-2xl font-bold">60</div>
      </div>
      <div class="bg-white/70 rounded-2xl p-3 shadow">
        <div class="text-xs text-slate-500">Popped</div>
        <div id="popped" class="text-xl md:text-2xl font-bold">0</div>
      </div>
      <div class="bg-white/70 rounded-2xl p-3 shadow">
        <div class="text-xs text-slate-500">Missed</div>
        <div id="missed" class="text-xl md:text-2xl font-bold">0</div>
      </div>
    </section>

    <div class="relative rounded-3xl overflow-hidden shadow-lg border border-white/70">
      <canvas id="game" class="w-full block bg-gradient-to-b from-sky-200 to-sky-300" width="900" height="520" aria-label="Balloon Pop Game" role="img"></canvas>
      <!-- Overlay messages -->
      <div id="overlay" class="pointer-events-none absolute inset-0 flex items-center justify-center">
        <div id="message" class="hidden bg-white/80 rounded-3xl px-6 py-5 text-center shadow-xl">
          <div id="msg-title" class="text-xl md:text-2xl font-extrabold text-sky-700 mb-2">Tap Start</div>
          <p id="msg-body" class="text-slate-700 text-sm md:text-base">Pop the balloons before they fly away.</p>
        </div>
      </div>
    </div>

    <footer class="mt-3 text-center text-slate-600 text-sm">
      Tip: Mobile users can tap balloons. Desktop users can click.
    </footer>
  </div>

  <script>
    // Game state
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const ui = {
      score: document.getElementById('score'),
      time: document.getElementById('time'),
      popped: document.getElementById('popped'),
      missed: document.getElementById('missed'),
      start: document.getElementById('btn-start'),
      reset: document.getElementById('btn-reset'),
      overlay: document.getElementById('overlay'),
      message: document.getElementById('message'),
      msgTitle: document.getElementById('msg-title'),
      msgBody: document.getElementById('msg-body'),
    };

    // Responsive canvas sizing to container width (keeps aspect ratio)
    function fitCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      const scale = rect.width / canvas.width;
      canvas.style.height = canvas.height * scale + 'px';
    }
    addEventListener('resize', fitCanvas);
    fitCanvas();

    const COLORS = ['#ef4444', '#f97316', '#f59e0b', '#22c55e', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'];

    const state = {
      running: false,
      score: 0,
      popped: 0,
      missed: 0,
      timeLeft: 60,
      lastSpawn: 0,
      spawnEvery: 900, // ms
      balloons: [],
      lastTime: 0,
    };

    class Balloon {
      constructor(x, radius, color, speed) {
        this.x = x;
        this.y = canvas.height + radius + Math.random() * 60; // start below view
        this.r = radius;
        this.color = color;
        this.speed = speed; // pixels/sec
        this.wobbleT = Math.random() * Math.PI * 2;
        this.wobbleAmp = 10 + Math.random() * 10;
        this.stringLen = radius * (1.5 + Math.random());
        this.popped = false;
      }
      update(dt) {
        this.y -= this.speed * dt;
        this.wobbleT += dt * (1 + this.r / 40);
        this.x += Math.sin(this.wobbleT) * 0.2; // gentle drift
      }
      draw(ctx) {
        // string
        ctx.strokeStyle = '#6b7280';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.r);
        ctx.lineTo(this.x, this.y + this.r + this.stringLen);
        ctx.stroke();

        // balloon body (oval)
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(1, 1.2);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI * 2);
        ctx.fill();

        // knot
        ctx.scale(1, 1/1.2);
        ctx.fillRect(-4, this.r - 2, 8, 6);

        // highlight
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.ellipse(-this.r/3, -this.r/3, this.r/5, this.r/8, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      hitTest(px, py) {
        // approximate with circle in scaled space
        const dx = px - this.x;
        const dy = (py - this.y) / 1.2; // inverse of scaleY
        return dx*dx + dy*dy <= this.r*this.r;
      }
    }

    function spawnBalloon() {
      const r = 18 + Math.random() * 26; // radius 18-44
      const x = r + Math.random() * (canvas.width - 2*r);
      const color = COLORS[Math.floor(Math.random() * COLORS.length)];
      const speed = 40 + Math.random() * 60; // px/sec
      state.balloons.push(new Balloon(x, r, color, speed));
    }

    function resetGame() {
      state.running = false;
      state.score = 0;
      state.popped = 0;
      state.missed = 0;
      state.timeLeft = 60;
      state.balloons = [];
      state.lastSpawn = 0;
      state.lastTime = 0;
      updateUI();
      showMessage('Tap Start', 'Pop the balloons before they fly away.');
      render();
    }

    function startGame() {
      if (state.running) return;
      state.running = true;
      hideMessage();
      state.lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function endGame() {
      state.running = false;
      showMessage('Time\'s up!', `Score: ${state.score}\nPopped: ${state.popped} | Missed: ${state.missed}`);
    }

    function updateUI() {
      ui.score.textContent = state.score;
      ui.time.textContent = Math.ceil(state.timeLeft);
      ui.popped.textContent = state.popped;
      ui.missed.textContent = state.missed;
    }

    function showMessage(title, body) {
      ui.msgTitle.textContent = title;
      ui.msgBody.textContent = body;
      ui.message.classList.remove('hidden');
    }
    function hideMessage() { ui.message.classList.add('hidden'); }

    function loop(now) {
      if (!state.running) return;
      const dt = Math.min(0.033, (now - state.lastTime) / 1000); // cap dt
      state.lastTime = now;

      // timer
      state.timeLeft -= dt;
      if (state.timeLeft <= 0) {
        state.timeLeft = 0;
        updateUI();
        endGame();
        return;
      }

      // spawn
      state.lastSpawn += dt * 1000;
      const dynamicSpawn = Math.max(350, state.spawnEvery - (60 - state.timeLeft) * 8);
      if (state.lastSpawn >= dynamicSpawn) {
        state.lastSpawn = 0;
        spawnBalloon();
        if (Math.random() < 0.35) spawnBalloon();
      }

      // update balloons
      for (let i = state.balloons.length - 1; i >= 0; i--) {
        const b = state.balloons[i];
        b.update(dt);
        if (b.y + b.r < 0) { // escaped
          state.balloons.splice(i, 1);
          state.missed += 1;
        }
      }

      updateUI();
      render();
      requestAnimationFrame(loop);
    }

    function render() {
      // background scene
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // clouds
      ctx.globalAlpha = 0.15;
      drawCloud(120, 90, 60);
      drawCloud(340, 60, 50);
      drawCloud(620, 100, 70);
      drawCloud(780, 50, 40);
      ctx.globalAlpha = 1;

      // ground
      const gH = 60;
      const grd = ctx.createLinearGradient(0, canvas.height - gH, 0, canvas.height);
      grd.addColorStop(0, '#86efac');
      grd.addColorStop(1, '#22c55e');
      ctx.fillStyle = grd;
      ctx.fillRect(0, canvas.height - gH, canvas.width, gH);

      // balloons
      state.balloons.forEach(b => b.draw(ctx));
    }

    function drawCloud(x, y, r) {
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(x, y, r * 0.8, 0, Math.PI * 2);
      ctx.arc(x + r * 0.7, y + r * 0.2, r, 0, Math.PI * 2);
      ctx.arc(x - r * 0.7, y + r * 0.2, r * 0.9, 0, Math.PI * 2);
      ctx.arc(x, y + r * 0.5, r * 0.9, 0, Math.PI * 2);
      ctx.fill();
    }

    // Input handling (mouse + touch)
    function handleHit(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;

      for (let i = state.balloons.length - 1; i >= 0; i--) {
        const b = state.balloons[i];
        if (b.hitTest(x, y)) {
          // pop
          state.balloons.splice(i, 1);
          state.popped += 1;
          state.score += 10;
          // simple pop visual (ring)
          popEffect(x, y, b.color);
          updateUI();
          return;
        }
      }
    }

    canvas.addEventListener('click', (e) => handleHit(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => {
      const t = e.changedTouches[0];
      handleHit(t.clientX, t.clientY);
    }, { passive: true });

    // Pop effect
    const effects = [];
    function popEffect(x, y, color) {
      effects.push({ x, y, r: 8, life: 0.25, color });
      // tiny confetti
      for (let i = 0; i < 8; i++) {
        effects.push({ x, y, vx: (Math.random()*2-1)*120, vy: (Math.random()*2-1)*120, s: 3+Math.random()*2, life: 0.5+Math.random()*0.4, color });
      }
    }

    function renderEffects(dt) {
      for (let i = effects.length - 1; i >= 0; i--) {
        const e = effects[i];
        e.life -= dt;
        if (e.life <= 0) { effects.splice(i, 1); continue; }
        if (e.vx !== undefined) {
          // confetti
          e.vy += 200 * dt; // gravity
          e.x += e.vx * dt;
          e.y += e.vy * dt;
          ctx.fillStyle = e.color;
          ctx.globalAlpha = Math.max(0, e.life);
          ctx.fillRect(e.x, e.y, e.s, e.s);
          ctx.globalAlpha = 1;
        } else {
          // ring
          ctx.strokeStyle = e.color;
          ctx.globalAlpha = Math.max(0, e.life);
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(e.x, e.y, (1 - e.life) * 28 + e.r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
    }

    // Patch render to include effects without changing main logic too much
    const _render = render;
    render = function() {
      _render();
      // run effects with a small dt assumption if not in loop
      renderEffects(1/60);
    }

    // Buttons
    ui.start.addEventListener('click', startGame);
    ui.reset.addEventListener('click', resetGame);

    // Initial state
    resetGame();
  </script>
</body>
</html>
